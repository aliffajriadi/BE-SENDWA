#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const __1 = __importDefault(require(".."));
const cookieManager_1 = require("../services/cookieManager");
const logger_1 = require("../lib/logger");
const chalk_1 = __importDefault(require("chalk"));
const downloadManager_1 = require("../services/downloadManager");
const api_1 = require("../constants/api");
const cookieManager = new cookieManager_1.CookieManager();
commander_1.program
    .name("tiktokdl")
    .description("TikTok downloader and search CLI tool")
    .version("1.0.0");
commander_1.program
    .command("download")
    .description("Download TikTok Video / Slide / Music")
    .argument("<url>", "TikTok Video / Slide / Music URL")
    .option("-o, --output <path>", "Output directory path")
    .option("-v, --version <version>", "Downloader version (v1/v2/v3)", "v1")
    .option("-p, --proxy <proxy>", "Proxy URL (http/https/socks)")
    .action(async (url, options) => {
    try {
        const outputPath = options.output || (0, downloadManager_1.getDefaultDownloadPath)();
        const version = options.version.toLowerCase();
        if (!["v1", "v2", "v3"].includes(version)) {
            throw new Error("Invalid version. Use v1, v2 or v3");
        }
        logger_1.Logger.info("Fetching media information...");
        const data = await __1.default.Downloader(url, {
            version: version,
            proxy: options.proxy
        });
        await (0, downloadManager_1.handleMediaDownload)(data, outputPath, version);
    }
    catch (error) {
        logger_1.Logger.error(`Error: ${error.message}`);
    }
});
const cookieCommand = commander_1.program.command("cookie").description("Cookie Manager");
cookieCommand
    .command("set <value>")
    .description("Set a cookie")
    .action((value) => {
    cookieManager.setCookie(value);
    logger_1.Logger.success("Cookie set successfully.");
});
cookieCommand
    .command("get")
    .description("Get cookie value")
    .action(() => {
    const cookie = cookieManager.getCookie();
    if (cookie) {
        logger_1.Logger.info(`Cookie: ${cookie}`);
    }
    else {
        logger_1.Logger.warning("No cookie found.");
    }
});
cookieCommand
    .command("delete")
    .description("Delete cookie")
    .action(() => {
    cookieManager.deleteCookie();
    logger_1.Logger.success("Cookie deleted successfully.");
});
const searchCommand = commander_1.program
    .command("search")
    .description("Search TikTok users or live streams");
searchCommand
    .command("user")
    .description("Search TikTok users")
    .argument("<keyword>", "Search keyword")
    .option("-p, --page <number>", "Page number", "1")
    .option("--proxy <proxy>", "Proxy URL (http/https/socks)")
    .action(async (keyword, options) => {
    try {
        const page = parseInt(options.page);
        const results = await __1.default.Search(keyword, {
            type: "user",
            cookie: cookieManager.getCookie(),
            page: page,
            proxy: options.proxy
        });
        if (results.status === "success") {
            const data = results.result;
            for (const [index, item] of data.entries()) {
                if (item.type === "user") {
                    logger_1.Logger.info(`---- USER ${index + 1} ----`);
                    logger_1.Logger.result(`Username: ${item.username}`, chalk_1.default.green);
                    logger_1.Logger.result(`Nickname: ${item.nickname}`, chalk_1.default.green);
                    logger_1.Logger.result(`Bio: ${item.signature}`, chalk_1.default.green);
                    logger_1.Logger.result(`Followers: ${item.followerCount}`, chalk_1.default.yellow);
                    logger_1.Logger.result(`Verified: ${item.isVerified ? "Yes" : "No"}`, chalk_1.default.yellow);
                    logger_1.Logger.result(`Profile URL: ${item.url}`, chalk_1.default.yellow);
                }
            }
            logger_1.Logger.info(`Total users: ${data.length}`);
        }
        else {
            logger_1.Logger.error(`Error: ${results.message}`);
        }
    }
    catch (error) {
        logger_1.Logger.error(`Error: ${error.message}`);
    }
});
searchCommand
    .command("live")
    .description("Search TikTok live streams")
    .argument("<keyword>", "Search keyword")
    .option("-p, --page <number>", "Page number", "1")
    .option("--proxy <proxy>", "Proxy URL (http/https/socks)")
    .action(async (keyword, options) => {
    try {
        const page = parseInt(options.page);
        const results = await __1.default.Search(keyword, {
            type: "live",
            cookie: cookieManager.getCookie(),
            page: page,
            proxy: options.proxy
        });
        if (results.status === "success") {
            const data = results.result;
            for (const [index, item] of data.entries()) {
                if (item.type === "live") {
                    logger_1.Logger.info(`---- LIVE ${index + 1} ----`);
                    logger_1.Logger.result(`Title: ${item.liveInfo.title}`, chalk_1.default.green);
                    logger_1.Logger.result(`Nickname: ${item.liveInfo.owner.nickname}`, chalk_1.default.green);
                    logger_1.Logger.result(`Username: ${item.liveInfo.owner.username}`, chalk_1.default.green);
                    logger_1.Logger.result(`Verified: ${item.liveInfo.owner.isVerified ? "Yes" : "No"}`, chalk_1.default.green);
                    logger_1.Logger.result(`Type Third Party: ${item.liveInfo.liveTypeThirdParty ? "Yes" : "No"}`, chalk_1.default.green);
                    logger_1.Logger.result(`Hashtag: ${item.liveInfo.hashtag}`, chalk_1.default.green);
                    logger_1.Logger.info(`---- STATISTICS ----`);
                    logger_1.Logger.result(`Likes: ${item.liveInfo.stats.likeCount}`, chalk_1.default.yellow);
                    logger_1.Logger.result(`Views: ${item.liveInfo.stats.viewerCount}`, chalk_1.default.yellow);
                    logger_1.Logger.result(`Users: ${item.liveInfo.stats.totalUser}`, chalk_1.default.yellow);
                }
            }
            logger_1.Logger.info(`Total live streams: ${data.length}`);
        }
        else {
            logger_1.Logger.error(`Error: ${results.message}`);
        }
    }
    catch (error) {
        logger_1.Logger.error(`Error: ${error.message}`);
    }
});
searchCommand
    .command("video")
    .description("Search TikTok videos")
    .argument("<keyword>", "Search keyword")
    .option("-p, --page <number>", "Page number", "1")
    .option("--proxy <proxy>", "Proxy URL (http/https/socks)")
    .action(async (keyword, options) => {
    try {
        const page = parseInt(options.page);
        const results = await __1.default.Search(keyword, {
            type: "video",
            cookie: cookieManager.getCookie(),
            page: page,
            proxy: options.proxy
        });
        if (results.status === "success") {
            const data = results.result;
            for (const [index, item] of data.entries()) {
                if (item.type === "video") {
                    logger_1.Logger.info(`---- VIDEO ${index + 1} ----`);
                    logger_1.Logger.result(`Video ID: ${item.id}`, chalk_1.default.green);
                    logger_1.Logger.result(`Description: ${item.desc}`, chalk_1.default.yellow);
                    logger_1.Logger.result(`Author: ${item.author.nickname}`, chalk_1.default.yellow);
                    logger_1.Logger.result(`Video URL: ${api_1._tiktokurl}/@${item.author.uniqueId}/video/${item.id}`, chalk_1.default.yellow);
                    logger_1.Logger.info(`---- STATISTICS ----`);
                    logger_1.Logger.result(`Likes: ${item.stats.likeCount}`, chalk_1.default.yellow);
                    logger_1.Logger.result(`Favorites: ${item.stats.collectCount}`, chalk_1.default.yellow);
                    logger_1.Logger.result(`Views: ${item.stats.playCount}`, chalk_1.default.yellow);
                    logger_1.Logger.result(`Shares: ${item.stats.shareCount}`, chalk_1.default.yellow);
                    logger_1.Logger.result(`Comments: ${item.stats.commentCount}`, chalk_1.default.yellow);
                }
            }
            logger_1.Logger.info(`Total videos: ${data.length}`);
        }
        else {
            logger_1.Logger.error(`Error: ${results.message}`);
        }
    }
    catch (error) {
        logger_1.Logger.error(`Error: ${error.message}`);
    }
});
commander_1.program
    .command("getvideocomments")
    .description("Get comments from a TikTok video")
    .argument("<url>", "TikTok video URL")
    .option("-l, --limit <number>", "Limit of comments", "10")
    .option("-p, --proxy <proxy>", "Proxy URL (http/https/socks)")
    .action(async (url, options) => {
    try {
        const limit = parseInt(options.limit);
        const comments = await __1.default.GetVideoComments(url, {
            commentLimit: limit,
            proxy: options.proxy
        });
        if (comments.status === "success") {
            const data = comments.result;
            for (const [index, comment] of data.entries()) {
                logger_1.Logger.info(`---- COMMENT ${index + 1} ----`);
                logger_1.Logger.result(`Username: ${comment.user.username}`, chalk_1.default.green);
                logger_1.Logger.result(`Text: ${comment.text}`, chalk_1.default.green);
                logger_1.Logger.result(`Likes: ${comment.likeCount}`, chalk_1.default.yellow);
            }
            logger_1.Logger.info(`Total comments: ${data.length}`);
        }
        else {
            logger_1.Logger.error(`Error: ${comments.message}`);
        }
    }
    catch (error) {
        logger_1.Logger.error(`Error: ${error.message}`);
    }
});
commander_1.program
    .command("getuserposts")
    .description("Get posts from a TikTok user")
    .argument("<username>", "TikTok username")
    .option("-l, --limit <number>", "Limit of posts", "5")
    .option("--proxy <proxy>", "Proxy URL (http/https/socks)")
    .action(async (username, options) => {
    try {
        const postLimit = parseInt(options.limit);
        const results = await __1.default.GetUserPosts(username, {
            postLimit: postLimit,
            proxy: options.proxy
        });
        if (results.status === "success") {
            const data = results.result;
            for (const [index, post] of data.entries()) {
                logger_1.Logger.info(`---- POST ${index + 1} ----`);
                logger_1.Logger.result(`Video ID: ${post.id}`, chalk_1.default.green);
                logger_1.Logger.result(`Description: ${post.desc}`, chalk_1.default.yellow);
                logger_1.Logger.info(`---- STATISTICS ----`);
                logger_1.Logger.result(`Likes: ${post.stats.likeCount}`, chalk_1.default.yellow);
                logger_1.Logger.result(`Favorites: ${post.stats.collectCount}`, chalk_1.default.yellow);
                logger_1.Logger.result(`Views: ${post.stats.playCount}`, chalk_1.default.yellow);
                logger_1.Logger.result(`Shares: ${post.stats.shareCount}`, chalk_1.default.yellow);
                logger_1.Logger.result(`Comments: ${post.stats.commentCount}`, chalk_1.default.yellow);
            }
            logger_1.Logger.info(`Total posts: ${data.length}`);
        }
        else {
            logger_1.Logger.error(`Error: ${results.message}`);
        }
    }
    catch (error) {
        logger_1.Logger.error(`Error: ${error.message}`);
    }
});
commander_1.program
    .command("getuserliked")
    .description("Get user liked videos from a TikTok user")
    .argument("<username>", "TikTok username")
    .option("-l, --limit <number>", "Limit of posts", "5")
    .option("--proxy <proxy>", "Proxy URL (http/https/socks)")
    .action(async (username, options) => {
    try {
        const postLimit = parseInt(options.limit);
        const results = await __1.default.GetUserLiked(username, {
            cookie: cookieManager.getCookie(),
            postLimit: postLimit,
            proxy: options.proxy
        });
        if (results.status === "success") {
            const data = results.result;
            for (const [index, liked] of data.entries()) {
                logger_1.Logger.info(`---- FAVORITE ${index + 1} ----`);
                logger_1.Logger.result(`Video ID: ${liked.id}`, chalk_1.default.green);
                logger_1.Logger.result(`Description: ${liked.desc}`, chalk_1.default.yellow);
                logger_1.Logger.result(`Author: ${liked.author.nickname}`, chalk_1.default.yellow);
                logger_1.Logger.result(`Video URL: ${api_1._tiktokurl}/@${liked.author.username}/video/${liked.video.id}`, chalk_1.default.yellow);
                logger_1.Logger.info(`---- STATISTICS ----`);
                logger_1.Logger.result(`Likes: ${liked.stats.diggCount}`, chalk_1.default.yellow);
                logger_1.Logger.result(`Favorites: ${liked.stats.collectCount}`, chalk_1.default.yellow);
                logger_1.Logger.result(`Views: ${liked.stats.playCount}`, chalk_1.default.yellow);
                logger_1.Logger.result(`Shares: ${liked.stats.shareCount}`, chalk_1.default.yellow);
                logger_1.Logger.result(`Comments: ${liked.stats.commentCount}`, chalk_1.default.yellow);
                logger_1.Logger.result(`Reposts: ${liked.stats.repostCount}`, chalk_1.default.yellow);
            }
            logger_1.Logger.info(`Total Liked Videos: ${data.length}`);
        }
        else {
            logger_1.Logger.error(`Error: ${results.message}`);
        }
    }
    catch (error) {
        logger_1.Logger.error(`Error: ${error.message}`);
    }
});
commander_1.program
    .command("stalk")
    .description("Stalk a TikTok user")
    .argument("<username>", "TikTok username")
    .option("--proxy <proxy>", "Proxy URL (http/https/socks)")
    .action(async (username, options) => {
    try {
        const results = await __1.default.StalkUser(username, {
            proxy: options.proxy
        });
        if (results.status === "success") {
            const data = results.result;
            logger_1.Logger.info("---- TIKTOK STALKER ----");
            logger_1.Logger.result(`Username:${data.user.username}`, chalk_1.default.green);
            logger_1.Logger.result(`Nickname:${data.user.nickname}`, chalk_1.default.green);
            logger_1.Logger.result(`Bio:${data.user.signature}`, chalk_1.default.green);
            logger_1.Logger.result(`Verified:${data.user.verified ? "Yes" : "No"}`, chalk_1.default.green);
            logger_1.Logger.result(`Commerce User:${data.user.commerceUser ? "Yes" : "No"}`, chalk_1.default.green);
            logger_1.Logger.result(`Private Account:${data.user.privateAccount ? "Yes" : "No"}`, chalk_1.default.green);
            logger_1.Logger.result(`Region:${data.user.region}`, chalk_1.default.green);
            logger_1.Logger.info("---- STATISTICS ----");
            logger_1.Logger.result(`Followers:${data.stats.followerCount}`, chalk_1.default.yellow);
            logger_1.Logger.result(`Following:${data.stats.followingCount}`, chalk_1.default.yellow);
            logger_1.Logger.result(`Hearts:${data.stats.heartCount}`, chalk_1.default.yellow);
            logger_1.Logger.result(`Videos:${data.stats.videoCount}`, chalk_1.default.yellow);
            logger_1.Logger.result(`Likes:${data.stats.likeCount}`, chalk_1.default.yellow);
            logger_1.Logger.result(`Friends:${data.stats.friendCount}`, chalk_1.default.yellow);
        }
        else {
            logger_1.Logger.error(`Error: ${results.message}`);
        }
    }
    catch (error) {
        logger_1.Logger.error(`Error: ${error.message}`);
    }
});
commander_1.program.parse();
